/*
 * Copyright (c) 2024 The ZMK Contributors
 * SPDX-License-Identifier: MIT
 *
 * Charybdis Nano Right Half (Peripheral)
 * This side has the PMW3610 trackball connected via 3-wire SPI.
 *
 * Trackball Pin Mappings (PMW3610):
 *   nCS    = P0.20 (D3)  - Chip Select
 *   SDIO   = P0.17 (D2)  - Bidirectional data (MOSI/MISO on same pin)
 *   SCLK   = P0.08 (D0)  - SPI Clock
 *   MOTION = P0.06 (D1)  - Interrupt/IRQ (directly connected, no SPI)
 */

#include "charybdis_nano.dtsi"
#include <dt-bindings/zmk/input_transform.h>
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <input/processors.dtsi>

/*
 * Matrix Transform Column Offset
 * Right half columns are offset by 5 (left half has 5 columns: 0-4).
 * So right half physical columns map to logical columns 5-9.
 */
&default_transform {
    col-offset = <5>;
};

/*
 * Column GPIO Configuration for Right Half
 * Same physical pins as left, but ORDER IS REVERSED because the PCB is mirrored.
 * col-offset shifts to columns 5-9.
 *
 * Diode direction is row2col, so columns are inputs (with pull-down).
 */
&kscan0 {
    /*
     * Column order is REVERSED from left half because the right PCB is
     * physically mirrored. The leftmost physical column on right side
     * corresponds to col 5 in the matrix.
     */
    col-gpios
        = <&gpio1  4 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>  /* C6 = P1.04 (D8)  -> col 5 (phys leftmost) */
        , <&gpio0 11 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>  /* C5 = P0.11 (D7)  -> col 6 */
        , <&gpio1  0 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>  /* C4 = P1.00 (D6)  -> col 7 */
        , <&gpio0  9 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>  /* C3 = P0.09 (D10) -> col 8 */
        , <&gpio0 29 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>  /* C2 = P0.29 (D20) -> col 9 (phys rightmost) */
        ;
};

/*
 * SPI Pin Control Configuration for PMW3610 Trackball
 *
 * PMW3610 uses 3-wire SPI with bidirectional SDIO.
 * MOSI and MISO are configured to the same pin (P0.17/D2) for bidirectional operation.
 * The MOTION/IRQ signal uses P0.06 (D1) separately.
 */
&pinctrl {
    spi0_default: spi0_default {
        group1 {
            psels = <NRF_PSEL(SPIM_SCK, 0, 8)>,   /* SCLK = P0.08 (D0) */
                    <NRF_PSEL(SPIM_MOSI, 0, 17)>, /* SDIO = P0.17 (D2) - bidirectional */
                    <NRF_PSEL(SPIM_MISO, 0, 17)>; /* SDIO = P0.17 (D2) - same as MOSI */
        };
    };

    spi0_sleep: spi0_sleep {
        group1 {
            psels = <NRF_PSEL(SPIM_SCK, 0, 8)>,
                    <NRF_PSEL(SPIM_MOSI, 0, 17)>,
                    <NRF_PSEL(SPIM_MISO, 0, 17)>;
            low-power-enable;
        };
    };
};

/*
 * SPI Bus Configuration
 */
&spi0 {
    status = "okay";
    compatible = "nordic,nrf-spim";
    pinctrl-0 = <&spi0_default>;
    pinctrl-1 = <&spi0_sleep>;
    pinctrl-names = "default", "sleep";
    cs-gpios = <&gpio0 20 GPIO_ACTIVE_LOW>;  /* nCS = P0.20 (D3) */

    trackball: trackball@0 {
        status = "okay";
        compatible = "pixart,pmw3610-alt";
        reg = <0>;
        spi-max-frequency = <2000000>;
        irq-gpios = <&gpio0 6 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;  /* MOTION = P0.06 (D1) */
        cpi = <800>;
        evt-type = <INPUT_EV_REL>;
        x-input-code = <INPUT_REL_X>;
        y-input-code = <INPUT_REL_Y>;
    };
};

/*
 * Configure Input Split for Trackball
 * This relays trackball events from peripheral to central.
 *
 * TRACKBALL AXIS CALIBRATION
 * ==========================
 * If cursor moves diagonally when rolling straight, try each option below.
 * Uncomment ONE option at a time, rebuild, and test.
 *
 * Test procedure:
 *   1. Roll ball straight LEFT  → cursor should move purely left
 *   2. Roll ball straight UP    → cursor should move purely up
 *   3. If diagonal, try next option
 *
 * Options (effective rotation):
 *   #1: 0°   - No transform
 *   #2: 90°  - XY_SWAP
 *   #3: 180° - X_INVERT | Y_INVERT
 *   #4: 270° - XY_SWAP | X_INVERT | Y_INVERT
 *
 * If none of #1-#4 work, try adding/removing individual inversions:
 *   #5: X_INVERT only
 *   #6: Y_INVERT only
 *   #7: XY_SWAP | X_INVERT
 *   #8: XY_SWAP | Y_INVERT
 *
 * If ALL 8 options still show diagonal movement, the sensor PCB
 * needs to be physically rotated by ~45° increments.
 */
/*
 * Temporary Layer Processor for Mouse Layer
 * Activates layer 5 (MOUSE) when trackball moves, deactivates after timeout.
 * Usage: <&zip_mouse_layer LAYER_NUM TIMEOUT_MS>
 */
/ {
    zip_mouse_layer: zip_mouse_layer {
        compatible = "zmk,input-processor-temp-layer";
        #input-processor-cells = <2>;
    };
};

&trackball_split {
    device = <&trackball>;

    /*
     * Input processors are chained: first temp-layer activation, then axis transform.
     * The mouse layer (5) activates on any trackball movement.
     *
     * AXIS TRANSFORM OPTIONS - uncomment ONE transform line below:
     */

    /* #1: No transform (0°) - TESTING */
    /* zip_mouse_layer params: layer 5, 500ms timeout */
    input-processors = <&zip_mouse_layer 5 500>;

    /* #2: 90° rotation */
    // input-processors = <&zip_mouse_layer 5 500>, <&zip_xy_transform INPUT_TRANSFORM_XY_SWAP>;

    /* #3: 180° rotation */
    // input-processors = <&zip_mouse_layer 5 500>, <&zip_xy_transform (INPUT_TRANSFORM_X_INVERT | INPUT_TRANSFORM_Y_INVERT)>;

    /* #4: 270° rotation */
    // input-processors = <&zip_mouse_layer 5 500>, <&zip_xy_transform (INPUT_TRANSFORM_XY_SWAP | INPUT_TRANSFORM_X_INVERT | INPUT_TRANSFORM_Y_INVERT)>;

    /* #5: X invert only */
    // input-processors = <&zip_mouse_layer 5 500>, <&zip_xy_transform INPUT_TRANSFORM_X_INVERT>;

    /* #6: Y invert only */
    // input-processors = <&zip_mouse_layer 5 500>, <&zip_xy_transform INPUT_TRANSFORM_Y_INVERT>;

    /* #7: 90° + X invert (was veering diagonally) */
    // input-processors = <&zip_mouse_layer 5 500>, <&zip_xy_transform (INPUT_TRANSFORM_XY_SWAP | INPUT_TRANSFORM_X_INVERT)>;

    /* #8: 90° + Y invert */
    // input-processors = <&zip_mouse_layer 5 500>, <&zip_xy_transform (INPUT_TRANSFORM_XY_SWAP | INPUT_TRANSFORM_Y_INVERT)>;
};
